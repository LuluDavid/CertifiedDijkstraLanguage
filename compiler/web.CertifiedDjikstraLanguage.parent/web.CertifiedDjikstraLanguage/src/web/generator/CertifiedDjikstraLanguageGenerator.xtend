/*
 * generated by Xtext 2.19.0
 */
package web.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.core.resources.ResourcesPlugin
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import web.certifiedDjikstraLanguage.Module
import web.certifiedDjikstraLanguage.Declaration
import web.certifiedDjikstraLanguage.Instantiation
import web.certifiedDjikstraLanguage.Transformation
import web.certifiedDjikstraLanguage.GraphInstantiation
import web.certifiedDjikstraLanguage.RootInstantiation
import web.certifiedDjikstraLanguage.Triplet
import web.certifiedDjikstraLanguage.Vertex
import web.certifiedDjikstraLanguage.TransformationBody
import web.certifiedDjikstraLanguage.GraphOrDecl
import web.certifiedDjikstraLanguage.RootOrDecl
import web.certifiedDjikstraLanguage.Graph
import web.certifiedDjikstraLanguage.Root
import web.certifiedDjikstraLanguage.DocDeclaration
import web.certifiedDjikstraLanguage.impl.TripletImpl
import web.certifiedDjikstraLanguage.impl.VertexImpl
import web.certifiedDjikstraLanguage.GraphDecl
import web.certifiedDjikstraLanguage.RootDecl
import java.util.List
import java.nio.file.Paths
import org.eclipse.core.runtime.IPath

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class CertifiedDjikstraLanguageGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val file = resource.URI.trimFileExtension.appendFileExtension('v').toString()
        val fileName = file.substring(file.lastIndexOf('/'))
        var project = file.substring(0, file.lastIndexOf('/'))
        project = project.substring(0, project.lastIndexOf('/'))
        val projectName = project.substring(project.lastIndexOf('/'))
        val workspace = project.substring(0, project.lastIndexOf('/'))
        val workspaceName = workspace.substring(workspace.lastIndexOf('/'))
		val finalUri = "/../.."+workspaceName+projectName+"/src-gen"+fileName
		for (o : resource.allContents.toIterable.filter(Module)) {
           fsa.generateFile(
           		finalUri,
                o.compile)
        }
     }
		
	def compile(Module module)
'''Require Import parcoursAvecCandidatSansListeContraint TactiquesParcoursContraint DjikstraCalculatoire.

Import Pondéré.

(** GENERATED WITH CertifiedDjikstraLanguage, DO NOT EDIT 
	
	To run the file, you should:
	-> download the project
	-> place the generated file inside it
	-> run the makefile (I would recommend make from CoqIde)
	-> then process the whole file and watch the console for complementary information

  *)

«FOR DocDeclaration declaration:module.declarations»
«declaration.compile»

«ENDFOR»'''
	
	def compile(DocDeclaration declaration)
'''«declaration.doc»
«declaration.declaration.compileDeclaration»'''
	
	def compileDeclaration(Declaration declaration)
'''«IF declaration instanceof Instantiation»
«(declaration as Instantiation).compile»
«ELSEIF declaration instanceof Transformation»
«(declaration as Transformation).compile»
«ENDIF»'''
	
	def compile(Instantiation instantiation)
'''«if (instantiation instanceof GraphInstantiation){(instantiation as GraphInstantiation).compileGraph}
	else if (instantiation instanceof RootInstantiation){(instantiation as RootInstantiation).compileRoot}
	else { UnexpectedType(instantiation.class, Instantiation)}»'''
	
	def compileRoot(RootInstantiation instantiation)
	'''Definition «instantiation.name» := «instantiation.root.compile».'''
	
	def compile(Root root)'''«root.^val.compile»'''
	
	def compileGraph(GraphInstantiation instantiation)
	'''Definition «instantiation.name» := «instantiation.graph.compile».'''
	
	def compile(Graph graph)'''g «FOR Triplet t: graph.arcs SEPARATOR ' ⊗ g '»«t.compile»«ENDFOR»'''
	
	def compile(Triplet t)'''«t.x.compile» «t.y.compile» «t.z.compile»'''
	
	def compile(Vertex v)'''«v.value»'''
	
	def compile(Transformation transformation)
'''«transformation.body.compileBody»'''
	
	def compileGraphOrDecl(GraphOrDecl graph)
	'''«IF graph instanceof GraphDecl»«(graph.eCrossReferences.get(0) as GraphInstantiation).name»«ELSEIF graph instanceof Graph»«(graph as Graph).compile»
	«ELSE»«UnexpectedType(graph.class, GraphOrDecl)»«ENDIF»'''
	
	def compileRootOrDecl(RootOrDecl root)
	'''«IF root instanceof RootDecl»«(root.eCrossReferences.get(0) as RootInstantiation).name»«ELSEIF root instanceof Root»«(root as Root).compile»
	«ELSE»«UnexpectedType(root.class, RootOrDecl)»«ENDIF»'''
	
	def compileBody(TransformationBody body)'''
« var root = body.root.compileRootOrDecl»« var graph = body.graph.compileGraphOrDecl»

(** Djikstra's final table for «graph» *)
Definition FinalTable«graph» := snd (Djikstra «root» «graph»).

(** Djikstra's arc generation tactic*)
Ltac generationTactic«graph» := addArcs (fst(Djikstra Root Graph)) (MoleculeToTriplets FinalTable«graph»).

(** Simple transformation test from «graph» to FinalTable«graph» *)
Theorem Recouvrement«graph»:
Transformation règles («graph+" ⊗ t "+root+" "+root+" 0"»)
					  («graph» ⊗ FinalTable«graph»).
Proof.
  (** Unfold the elements *)
	unfold «graph».
	unfold «root».
  	remember FinalTable«graph» as H.
	cbv in HeqH; subst.

	(** Generate the graph *)
	generationTactic«graph».
	
	(** Check the final constraints *)
	ChoisirNeutrePartout.
	ConclureCandidat1.
	ConclureCandidat2.
Qed.
'''
	
	// Utils
	
	
	def Vertex Vertex(int x){
		var res = new VertexImpl();
		res.value = x;
		return res;
	}
	
	def Triplet Triplet(Vertex x, Vertex y, Vertex z){
		var res = new TripletImpl();
		res.x = cloneVertex(x);
		res.y = cloneVertex(y);
		res.z = cloneVertex(z);
		return res;
	}
	
	def Triplet RootTriplet(Root root){
		var rootTriplet = new TripletImpl();
		rootTriplet.x = cloneVertex(root.^val);
		rootTriplet.y = cloneVertex(root.^val);
		rootTriplet.z = Vertex(0);
		return rootTriplet;
	}
	
	
	
	def Triplet SumZ(Triplet t1, Triplet t2){
		return Triplet(t1.x, t1.y, Vertex(t1.z.value + t2.z.value));
	}
	
	def String getName(RootOrDecl rootOrDecl){
		if (rootOrDecl instanceof RootDecl){
			return (rootOrDecl.eCrossReferences.get(0) as RootInstantiation).name;
		}
		return "";
	}
					  
	def String getName(GraphOrDecl graphOrDecl){
		if (graphOrDecl instanceof GraphDecl){
			return (graphOrDecl.eCrossReferences.get(0) as GraphInstantiation).name;
		}
		return "";
	}
	
	def Graph getGraph(GraphOrDecl graphOrDecl){
		if (graphOrDecl instanceof Graph){
			return (graphOrDecl as Graph);
		}
		else if (graphOrDecl instanceof GraphDecl){
			return (graphOrDecl.eCrossReferences.get(0) as GraphInstantiation).graph;
		}
		else {
			UnexpectedType(graphOrDecl.class, GraphOrDecl);
		}
	}
	
	def Root getRoot(RootOrDecl rootOrDecl){
		if (rootOrDecl instanceof Root){
			return (rootOrDecl as Root);
		}
		else if (rootOrDecl instanceof RootDecl){
			return (rootOrDecl.eCrossReferences.get(0) as RootInstantiation).root;
		}
		else {
			UnexpectedType(rootOrDecl.class, RootOrDecl);
		}
	}
	
	def void addRoot(Graph graph, Root root){
		graph.arcs.add(RootTriplet(root));
	}
	
	def void addRoot(List<Triplet> list, Root root){
		list.add(RootTriplet(root));
	}
	
	def Vertex cloneVertex(Vertex v){
		return Vertex(v.value);
	}
	
	def void removeArcList(List<Triplet> list, Triplet t){
		list.remove(list.indexOf(t));
	}
	
	def void addArcList(List<Triplet> list, Triplet t){
		list.add(t);
	}
	
	def void addArc(GraphOrDecl graphOrDecl, Triplet t){
		if (graphOrDecl instanceof Graph){
			(graphOrDecl as Graph).arcs.add(t);
		}
		else if (graphOrDecl instanceof GraphDecl){
			(graphOrDecl.eCrossReferences.get(0) as GraphInstantiation).graph.arcs.add(t);
		}
		else {
			UnexpectedType(graphOrDecl.class, GraphOrDecl);
		}
	}
	
	def printListPair(List<Pair<Vertex,Vertex>> list)'''«list.map[t|println("( "+t.key.value+", "+t.value.value+" )")]»'''
	
	def printList(List<Triplet> list)'''«list.map[Triplet t|println("( "+t.x.value+", "+t.y.value+", "+t.z.value+" )")]»'''
	
	
	def <T> T UnexpectedType(Class<?> c, Class<?> superc) throws Error{
		throw new Error("UnexpectedType: found subType " + c + " instead for superType "+superc+".");
	}
	
}
