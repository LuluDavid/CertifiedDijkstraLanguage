/*
 * generated by Xtext 2.19.0
 */
package org.xtext.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.certifiedDjikstraLanguage.Module
import org.xtext.certifiedDjikstraLanguage.Declaration
import org.xtext.certifiedDjikstraLanguage.Instantiation
import org.xtext.certifiedDjikstraLanguage.Transformation
import org.xtext.certifiedDjikstraLanguage.GraphInstantiation
import org.xtext.certifiedDjikstraLanguage.RootInstantiation
import org.xtext.certifiedDjikstraLanguage.Triplet
import org.xtext.certifiedDjikstraLanguage.Vertex
import org.xtext.certifiedDjikstraLanguage.TransformationBody
import org.xtext.certifiedDjikstraLanguage.GraphOrDecl
import org.xtext.certifiedDjikstraLanguage.RootOrDecl
import org.xtext.certifiedDjikstraLanguage.Graph
import org.xtext.certifiedDjikstraLanguage.Root
import org.xtext.certifiedDjikstraLanguage.DocDeclaration
import org.xtext.certifiedDjikstraLanguage.impl.TripletImpl
import org.xtext.certifiedDjikstraLanguage.impl.VertexImpl
import org.xtext.certifiedDjikstraLanguage.GraphDecl
import org.xtext.certifiedDjikstraLanguage.RootDecl
import java.util.List

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class CertifiedDjikstraLanguageGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for (o : resource.allContents.toIterable.filter(Module)) {
           fsa.generateFile(
           	"Example.v",
                o.compile)
        }
     }
		
	def compile(Module module)
'''Require Import parcoursAvecCandidatSansListeContraint TactiquesParcoursContraint DjikstraCalculatoire.

Import Pondéré.

(** GENERATED WITH CertifiedDjikstraLanguage, DO NOT EDIT 
	
	To run the file, you should:
	-> download the project
	-> place the generated file inside it
	-> run the makefile (I would recommend make from CoqIde)
	-> then process the whole file and watch the console for complementary information

  *)

«FOR DocDeclaration declaration:module.declarations»
«declaration.compile»

«ENDFOR»'''
	
	def compile(DocDeclaration declaration)
'''«declaration.doc»
«declaration.declaration.compileDeclaration»'''
	
	def compileDeclaration(Declaration declaration)
'''«IF declaration instanceof Instantiation»
«(declaration as Instantiation).compile»
«ELSEIF declaration instanceof Transformation»
«(declaration as Transformation).compile»
«ENDIF»'''
	
	def compile(Instantiation instantiation)
'''«if (instantiation instanceof GraphInstantiation){(instantiation as GraphInstantiation).compileGraph}
	else if (instantiation instanceof RootInstantiation){(instantiation as RootInstantiation).compileRoot}
	else { UnexpectedType(instantiation.class, Instantiation)}»'''
	
	def compileRoot(RootInstantiation instantiation)
	'''Definition «instantiation.name» := «instantiation.root.compile».'''
	
	def compile(Root root)'''«root.^val.compile»'''
	
	def compileGraph(GraphInstantiation instantiation)
	'''Definition «instantiation.name» := «instantiation.graph.compile».'''
	
	def compile(Graph graph)'''g «FOR Triplet t: graph.arcs SEPARATOR ' ⊗ g '»«t.compile»«ENDFOR»'''
	
	def compile(Triplet t)'''«t.x.compile» «t.y.compile» «t.z.compile»'''
	
	def compile(Vertex v)'''«v.value»'''
	
	def compile(Transformation transformation)
'''«transformation.body.compileBody»'''
	
	def compileGraphOrDecl(GraphOrDecl graph)
	'''«IF graph instanceof GraphDecl»«(graph.eCrossReferences.get(0) as GraphInstantiation).name»«ELSEIF graph instanceof Graph»«(graph as Graph).compile»
	«ELSE»«UnexpectedType(graph.class, GraphOrDecl)»«ENDIF»'''
	
	def compileRootOrDecl(RootOrDecl root)
	'''«IF root instanceof RootDecl»«(root.eCrossReferences.get(0) as RootInstantiation).name»«ELSEIF root instanceof Root»«(root as Root).compile»
	«ELSE»«UnexpectedType(root.class, RootOrDecl)»«ENDIF»'''
	
	def compileBody(TransformationBody body)'''
« var root = body.root.compileRootOrDecl»« var graph = body.graph.compileGraphOrDecl»

(** Djikstra's final table for «graph» *)
Definition FinalTable«graph» := snd (Djikstra «root» «graph»).

(** Djikstra's arc generation tactic*)
Ltac generationTactic«graph» := addArcs (fst(Djikstra Root Graph)) (MoleculeToTriplets FinalTable«graph»).

(** Simple transformation test from «graph» to FinalTable«graph» *)
Theorem Recouvrement«graph»:
Transformation règles («graph+" ⊗ t "+root+" "+root+" 0"»)
					  («graph» ⊗ FinalTable«graph»).
Proof.
  (** Unfold the elements *)
	unfold «graph».
	unfold «root».
  	remember FinalTable«graph» as H.
	cbv in HeqH; subst.

	(** Generate the graph *)
	generationTactic«graph».
	
	(** Check the final constraints *)
	ChoisirNeutrePartout.
	ConclureCandidat1.
	ConclureCandidat2.
Qed.
'''
	
	// Utils
	
	
	def Vertex Vertex(int x){
		var res = new VertexImpl();
		res.value = x;
		return res;
	}
	
	def Triplet Triplet(Vertex x, Vertex y, Vertex z){
		var res = new TripletImpl();
		res.x = cloneVertex(x);
		res.y = cloneVertex(y);
		res.z = cloneVertex(z);
		return res;
	}
	
	def Triplet RootTriplet(Root root){
		var rootTriplet = new TripletImpl();
		rootTriplet.x = cloneVertex(root.^val);
		rootTriplet.y = cloneVertex(root.^val);
		rootTriplet.z = Vertex(0);
		return rootTriplet;
	}
	
	
	
	def Triplet SumZ(Triplet t1, Triplet t2){
		return Triplet(t1.x, t1.y, Vertex(t1.z.value + t2.z.value));
	}
	
	def String getName(RootOrDecl rootOrDecl){
		if (rootOrDecl instanceof RootDecl){
			return (rootOrDecl.eCrossReferences.get(0) as RootInstantiation).name;
		}
		return "";
	}
					  
	def String getName(GraphOrDecl graphOrDecl){
		if (graphOrDecl instanceof GraphDecl){
			return (graphOrDecl.eCrossReferences.get(0) as GraphInstantiation).name;
		}
		return "";
	}
	
	def Graph getGraph(GraphOrDecl graphOrDecl){
		if (graphOrDecl instanceof Graph){
			return (graphOrDecl as Graph);
		}
		else if (graphOrDecl instanceof GraphDecl){
			return (graphOrDecl.eCrossReferences.get(0) as GraphInstantiation).graph;
		}
		else {
			UnexpectedType(graphOrDecl.class, GraphOrDecl);
		}
	}
	
	def Root getRoot(RootOrDecl rootOrDecl){
		if (rootOrDecl instanceof Root){
			return (rootOrDecl as Root);
		}
		else if (rootOrDecl instanceof RootDecl){
			return (rootOrDecl.eCrossReferences.get(0) as RootInstantiation).root;
		}
		else {
			UnexpectedType(rootOrDecl.class, RootOrDecl);
		}
	}
	
	def void addRoot(Graph graph, Root root){
		graph.arcs.add(RootTriplet(root));
	}
	
	def void addRoot(List<Triplet> list, Root root){
		list.add(RootTriplet(root));
	}
	
	def Vertex cloneVertex(Vertex v){
		return Vertex(v.value);
	}
	
	def void removeArcList(List<Triplet> list, Triplet t){
		list.remove(list.indexOf(t));
	}
	
	def void addArcList(List<Triplet> list, Triplet t){
		list.add(t);
	}
	
	def void addArc(GraphOrDecl graphOrDecl, Triplet t){
		if (graphOrDecl instanceof Graph){
			(graphOrDecl as Graph).arcs.add(t);
		}
		else if (graphOrDecl instanceof GraphDecl){
			(graphOrDecl.eCrossReferences.get(0) as GraphInstantiation).graph.arcs.add(t);
		}
		else {
			UnexpectedType(graphOrDecl.class, GraphOrDecl);
		}
	}
	
	def printListPair(List<Pair<Vertex,Vertex>> list)'''«list.map[t|println("( "+t.key.value+", "+t.value.value+" )")]»'''
	
	def printList(List<Triplet> list)'''«list.map[Triplet t|println("( "+t.x.value+", "+t.y.value+", "+t.z.value+" )")]»'''
	
	
	def <T> T UnexpectedType(Class<?> c, Class<?> superc) throws Error{
		throw new Error("UnexpectedType: found subType " + c + " instead for superType "+superc+".");
	}
	
}
