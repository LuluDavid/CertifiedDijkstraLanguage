/*
 * generated by Xtext 2.19.0
 */
package org.xtext.validation

import org.xtext.certifiedDjikstraLanguage.Graph
import org.eclipse.xtext.validation.Check
import org.eclipse.emf.common.util.EList
import org.xtext.certifiedDjikstraLanguage.Triplet
import org.xtext.certifiedDjikstraLanguage.Root
import org.xtext.certifiedDjikstraLanguage.TransformationBody
import org.xtext.certifiedDjikstraLanguage.Vertex
import org.xtext.certifiedDjikstraLanguage.impl.VertexImpl
import org.xtext.certifiedDjikstraLanguage.GraphOrDecl
import org.xtext.certifiedDjikstraLanguage.GraphDecl
import org.xtext.certifiedDjikstraLanguage.GraphInstantiation
import org.xtext.certifiedDjikstraLanguage.RootOrDecl
import org.xtext.certifiedDjikstraLanguage.RootDecl
import org.xtext.certifiedDjikstraLanguage.RootInstantiation
import org.eclipse.xtext.nodemodel.util.NodeModelUtils

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class CertifiedDjikstraLanguageValidator extends AbstractCertifiedDjikstraLanguageValidator {
	
	// Check whether the graph has one ponderation per arc
	@Check
	def CheckFunctionalGraph(Graph graph){
		CheckFunctionalList(graph.arcs);
	}
	
	@Check
	def CheckFunctionalList(EList<Triplet> list) {
		for (Triplet t:list){
			val x = t.x.value;
			val y = t.y.value;
			val cardinal = list.filter[Triplet t_| t_.x.value === x && t_.y.value === y].size;
			if (cardinal != 1){
				val node = NodeModelUtils.findActualNodeFor(t);
				messageAcceptor.acceptError(
				'Multiple different ponderations ('+cardinal+' values) for triplet x = "+x+", y = '+y+'.',
				t, node.offset, node.length, "(" + t.x.value +", " + t.y.value +")");
			}
		}
	}
	
	@Check
	def CheckRoot(TransformationBody body) throws Error {
		var graph = body.graph.getGraph;
		var root = body.root.getRoot;
		val rootValue = Vertex(root.^val.value);
		if (!graph.arcs.exists[Triplet t|t.x.value === rootValue.value]){
			val node = NodeModelUtils.findActualNodeFor(body.root)
			messageAcceptor.acceptWarning(
			'Root value is not used in the initial graph.',body,node.offset,node.length,root.^val.value.toString);
		}
	}
	
	// Utils
	
	def Graph getGraph(GraphOrDecl graphOrDecl){
		if (graphOrDecl instanceof Graph){
			return (graphOrDecl as Graph);
		}
		else if (graphOrDecl instanceof GraphDecl){
			return (graphOrDecl.eCrossReferences.get(0) as GraphInstantiation).graph;
		}
	}
	
	def Root getRoot(RootOrDecl rootOrDecl){
		if (rootOrDecl instanceof Root){
			return (rootOrDecl as Root);
		}
		else if (rootOrDecl instanceof RootDecl){
			return (rootOrDecl.eCrossReferences.get(0) as RootInstantiation).root;
		}
	}
	
	def Vertex Vertex(int x){
		var res = new VertexImpl();
		res.value = x;
		return res;
	}
}
